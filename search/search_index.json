{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#github-workflows-kt","title":"GitHub Workflows Kt","text":"<p>You won't go back to YAML!</p>"},{"location":"#work-in-progress-moving-fast-phase","title":"\ud83e\uddea Work in progress - \"moving fast\" phase","text":"<p>Please expect breaking API changes (they're documented in release notes) and missing features.</p>"},{"location":"#idea","title":"\ud83d\udca1 Idea","text":"<p>YAMLs and JSONs surround us more and more frequently. While their syntax is simple and they allow defining hierarchical data easily, the tendency is also to overuse them for more complicated scenarios where a power of a regular programming language would be beneficial. This library aims at filling this gap, utilizing Kotlin as a modern general-purpose language with good internal DSL support.</p>"},{"location":"#benefits","title":"\u2728 Benefits","text":"<ul> <li>no more confusion about YAML's indent level - Kotlin's syntax doesn't rely on it</li> <li>thanks to Kotlin being a compiled language, adds a compilation phase where a number of errors can be caught and   prevented from getting into your workflows' runtime phase</li> <li>superb IDE support: author your workflows in any IDE that supports Kotlin, with auto-completion</li> <li>remove duplication: ability to extract common parts to constants or functions</li> <li>programmatically generate your workflow's arbitrarily complex logic, you can even call an external service and   generate your workflow based on the response. Whatever Kotlin and the JVM allows you to do</li> </ul>"},{"location":"#video-presentation","title":"\ud83c\udfa5 Video presentation","text":"<p>Here's a detailed presentation of the library by Piotr Krzemi\u0144ski, along with simple demos:</p> <p></p>"},{"location":"feature-coverage/","title":"Feature coverage","text":"<p>Here's a list of GitHub Actions features supported by the library, and known to be unsupported yet.</p> <p>Legend:</p> <ul> <li>\u2705 - fully supported</li> <li>\u2705/\u274c - partially supported</li> <li>\u274c - not supported</li> </ul> Feature Support Tracking issue Conditions \u2705 Continue on error \u2705 Concurrency \u2705 Dependent jobs \u2705 Different types of triggers \u2705 Different types of workers \u2705 Environment variables (<code>env</code> context) \u2705 <code>github</code> context \u2705 Job containers \u2705 Docker actions \u2705 Local actions \u2705 <code>outcome</code> context \u274c #296 Permissions \u2705 Public actions \u2705 <code>runner</code> context \u2705 Strategy matrix (<code>matrix</code> context) \u2705/\u274c #368 Secrets (<code>secrets</code> context) \u2705 Service containers \u2705 Timeouts \u2705 Workflow dispatch inputs (<code>inputs</code> context) \u2705/\u274c #811"},{"location":"projects-using-this-library/","title":"Projects using this library","text":""},{"location":"projects-using-this-library/#projects-using-this-library","title":"Projects using this library","text":"<p>It's also a great source of examples how to use the library.</p> <ul> <li>aSoft-Ltd/oss</li> <li>awscdk-dsl-kotlin</li> <li>factcast</li> <li>github-actions-typing</li> <li>github-workflows-kt (this library - we dogfood, of course)</li> <li>greenback</li> <li>kotlin-python</li> <li>markout</li> <li>Petals</li> <li>setup-wsl</li> <li>snakeyaml-engine-kmp</li> <li>spring-cqs</li> <li>twitch-announcement-discord-bot</li> <li>WiertarBot</li> <li>feel free to add your project here!</li> </ul>"},{"location":"supported-actions/","title":"Supported actions","text":"<p>This is a complete list of actions for which the library provides typed wrappers, grouped by owners. If your action is not on the list, see Using actions section.</p> <p>Click on a version to see the wrapper's code.</p>"},{"location":"supported-actions/#wrappers","title":"Wrappers","text":"<ul> <li>8398a7<ul> <li>action-slack - v3: <code>ActionSlackV3</code></li> </ul> </li> <li>actions-rs<ul> <li>audit-check - v1: <code>AuditCheckV1</code></li> <li>cargo - v1: <code>CargoV1</code></li> <li>clippy-check - v1: <code>ClippyCheckV1</code></li> <li>toolchain - v1: <code>ToolchainV1</code></li> </ul> </li> <li>actions<ul> <li>cache/restore - v3: <code>CacheRestoreV3</code></li> <li>cache/save - v3: <code>CacheSaveV3</code></li> <li>cache - v2: <code>CacheV2</code>, v3: <code>CacheV3</code></li> <li>checkout - v2: <code>CheckoutV2</code>, v3: <code>CheckoutV3</code></li> <li>create-release - v1: <code>CreateReleaseV1</code></li> <li>download-artifact - v2: <code>DownloadArtifactV2</code>, v3: <code>DownloadArtifactV3</code></li> <li>first-interaction - v1: <code>FirstInteractionV1</code></li> <li>github-script - v6: <code>GithubScriptV6</code></li> <li>labeler - v4: <code>LabelerV4</code></li> <li>setup-dotnet - v2: <code>SetupDotnetV2</code>, v3: <code>SetupDotnetV3</code></li> <li>setup-go - v3: <code>SetupGoV3</code>, v4: <code>SetupGoV4</code></li> <li>setup-java - v2: <code>SetupJavaV2</code>, v3: <code>SetupJavaV3</code></li> <li>setup-node - v2: <code>SetupNodeV2</code>, v3: <code>SetupNodeV3</code></li> <li>setup-python - v2: <code>SetupPythonV2</code>, v3: <code>SetupPythonV3</code>, v4: <code>SetupPythonV4</code></li> <li>stale - v5: <code>StaleV5</code>, v6: <code>StaleV6</code>, v7: <code>StaleV7</code>, v8: <code>StaleV8</code></li> <li>upload-artifact - v2: <code>UploadArtifactV2</code>, v3: <code>UploadArtifactV3</code></li> </ul> </li> <li>anmol098<ul> <li>waka-readme-stats - v4: <code>WakaReadmeStatsV4</code></li> </ul> </li> <li>anothrNick<ul> <li>github-tag-action - v1: <code>GithubTagActionV1</code></li> </ul> </li> <li>aws-actions<ul> <li>amazon-ecr-login - v1: <code>AmazonEcrLoginV1</code></li> <li>amazon-ecs-deploy-task-definition - v1: <code>AmazonEcsDeployTaskDefinitionV1</code></li> <li>amazon-ecs-render-task-definition - v1: <code>AmazonEcsRenderTaskDefinitionV1</code></li> <li>configure-aws-credentials - v1: <code>ConfigureAwsCredentialsV1</code>, v2: <code>ConfigureAwsCredentialsV2</code></li> </ul> </li> <li>axel-op<ul> <li>googlejavaformat-action - v3: <code>GooglejavaformatActionV3</code></li> </ul> </li> <li>Azure<ul> <li>docker-login - v1: <code>DockerLoginV1</code></li> <li>login - v1: <code>LoginV1</code></li> <li>webapps-deploy - v2: <code>WebappsDeployV2</code></li> </ul> </li> <li>bahmutov<ul> <li>npm-install - v1: <code>NpmInstallV1</code></li> </ul> </li> <li>Borales<ul> <li>actions-yarn - v3: <code>ActionsYarnV3</code>, v4: <code>ActionsYarnV4</code></li> </ul> </li> <li>burrunan<ul> <li>gradle-cache-action - v1 \u2705: <code>GradleCacheActionV1</code></li> </ul> </li> <li>c2corg<ul> <li>browserslist-update-action - v2 \u2705: <code>BrowserslistUpdateActionV2</code></li> <li>transifex-pull-request-action - v5 \u2705: <code>TransifexPullRequestActionV5</code></li> </ul> </li> <li>cachix<ul> <li>install-nix-action - v17: <code>InstallNixActionV17</code>, v18: <code>InstallNixActionV18</code>, v19: <code>InstallNixActionV19</code>, v20: <code>InstallNixActionV20</code>, v21: <code>InstallNixActionV21</code>, v22: <code>InstallNixActionV22</code></li> </ul> </li> <li>codecov<ul> <li>codecov-action - v3: <code>CodecovActionV3</code></li> </ul> </li> <li>cycjimmy<ul> <li>semantic-release-action - v3: <code>SemanticReleaseActionV3</code></li> </ul> </li> <li>docker<ul> <li>build-push-action - v2: <code>BuildPushActionV2</code>, v3: <code>BuildPushActionV3</code>, v4: <code>BuildPushActionV4</code></li> <li>login-action - v1: <code>LoginActionV1</code>, v2: <code>LoginActionV2</code></li> <li>metadata-action - v4: <code>MetadataActionV4</code></li> <li>setup-buildx-action - v1: <code>SetupBuildxActionV1</code>, v2: <code>SetupBuildxActionV2</code></li> </ul> </li> <li>elgohr<ul> <li>Publish-Docker-Github-Action - v4: <code>PublishDockerGithubActionV4</code>, v5: <code>PublishDockerGithubActionV5</code></li> </ul> </li> <li>EndBug<ul> <li>add-and-commit - v8: <code>AddAndCommitV8</code>, v9: <code>AddAndCommitV9</code></li> </ul> </li> <li>entrostat<ul> <li>git-secret-action - v4 \u2705: <code>GitSecretActionV4</code></li> </ul> </li> <li>ericcornelissen<ul> <li>git-tag-annotation-action - v2 \u2705: <code>GitTagAnnotationActionV2</code></li> <li>svgo-action - v3 \u2705: <code>SvgoActionV3</code></li> </ul> </li> <li>gautamkrishnar<ul> <li>blog-post-workflow - v1: <code>BlogPostWorkflowV1</code></li> </ul> </li> <li>github<ul> <li>codeql-action/analyze - v2: <code>CodeqlActionAnalyzeV2</code></li> <li>codeql-action/autobuild - v2: <code>CodeqlActionAutobuildV2</code></li> <li>codeql-action/init - v2: <code>CodeqlActionInitV2</code></li> <li>codeql-action/upload-sarif - v2: <code>CodeqlActionUploadSarifV2</code></li> </ul> </li> <li>google-github-actions<ul> <li>auth - v0: <code>AuthV0</code>, v1: <code>AuthV1</code></li> <li>setup-gcloud - v0: <code>SetupGcloudV0</code>, v1: <code>SetupGcloudV1</code></li> </ul> </li> <li>GoogleCloudPlatform<ul> <li>github-actions - v0: <code>GithubActionsV0</code>, v1: <code>GithubActionsV1</code></li> </ul> </li> <li>gradle-update<ul> <li>update-gradle-wrapper-action - v1: <code>UpdateGradleWrapperActionV1</code></li> </ul> </li> <li>gradle<ul> <li>gradle-build-action - v2: <code>GradleBuildActionV2</code></li> <li>wrapper-validation-action - v1: <code>WrapperValidationActionV1</code></li> </ul> </li> <li>JamesIves<ul> <li>github-pages-deploy-action - v4: <code>GithubPagesDeployActionV4</code></li> </ul> </li> <li>JasonEtco<ul> <li>create-an-issue - v2: <code>CreateAnIssueV2</code></li> </ul> </li> <li>julia-actions<ul> <li>setup-julia - v1: <code>SetupJuliaV1</code></li> </ul> </li> <li>madhead<ul> <li>check-gradle-version - v1 \u2705: <code>CheckGradleVersionV1</code></li> <li>intellij-http-client-action - v0 \u2705: <code>IntellijHttpClientActionV0</code>, v231 \u2705: <code>IntellijHttpClientActionV231</code></li> <li>semver-utils - v2 \u2705: <code>SemverUtilsV2</code>, v3 \u2705: <code>SemverUtilsV3</code></li> </ul> </li> <li>mi-kas<ul> <li>kover-report - v1 \u2705: <code>KoverReportV1</code></li> </ul> </li> <li>microsoft<ul> <li>setup-msbuild - v1 \u2705: <code>SetupMsbuildV1</code></li> </ul> </li> <li>nobrayner<ul> <li>discord-webhook - v1: <code>DiscordWebhookV1</code></li> </ul> </li> <li>peaceiris<ul> <li>actions-gh-pages - v3: <code>ActionsGhPagesV3</code></li> <li>actions-hugo - v2: <code>ActionsHugoV2</code></li> </ul> </li> <li>peter-evans<ul> <li>create-issue-from-file - v4: <code>CreateIssueFromFileV4</code></li> <li>create-pull-request - v4: <code>CreatePullRequestV4</code>, v5: <code>CreatePullRequestV5</code></li> </ul> </li> <li>ReactiveCircus<ul> <li>android-emulator-runner - v2 \u2705: <code>AndroidEmulatorRunnerV2</code></li> </ul> </li> <li>repo-sync<ul> <li>pull-request - v2: <code>PullRequestV2</code></li> </ul> </li> <li>ruby<ul> <li>setup-ruby - v1: <code>SetupRubyV1</code></li> </ul> </li> <li>softprops<ul> <li>action-gh-release - v1: <code>ActionGhReleaseV1</code></li> </ul> </li> <li>stefanzweifel<ul> <li>git-auto-commit-action - v4: <code>GitAutoCommitActionV4</code></li> </ul> </li> <li>subosito<ul> <li>flutter-action - v2: <code>FlutterActionV2</code></li> </ul> </li> <li>supercharge<ul> <li>mongodb-github-action - v1 \u2705: <code>MongodbGithubActionV1</code></li> </ul> </li> <li>superfly<ul> <li>flyctl-actions/setup-flyctl - v1: <code>FlyctlActionsSetupFlyctlV1</code></li> </ul> </li> <li>typesafegithub<ul> <li>github-actions-typing - v0 \u2705: <code>GithubActionsTypingV0</code>, v1 \u2705: <code>GithubActionsTypingV1</code></li> </ul> </li> <li>Vampire<ul> <li>setup-wsl - v1 \u2705: <code>SetupWslV1</code>, v2 \u2705: <code>SetupWslV2</code></li> </ul> </li> </ul>"},{"location":"supported-actions/#statistics","title":"Statistics","text":"<p>Number of wrappers available:</p> <ul> <li>counting by actions: 82</li> <li>counting each version separately: 116</li> </ul> <p>Actions providing typings (marked with \u2705 on the above list): 15</p>"},{"location":"user-guide/compensating-librarys-missing-features/","title":"Compensating library's missing features","text":""},{"location":"user-guide/compensating-librarys-missing-features/#compensating-librarys-missing-features","title":"Compensating library's missing features","text":"<p>You may find yourself willing to use GitHub Actions' feature that is not yet reflected in this library, neither in the core workflows/jobs/steps API, nor in the action wrappers. We've thought about it. The library provides several points of extension so that you can keep using it, and in the meantime report the missing feature to us so that we can add it to one of the next releases. See the below sections to find your specific case.</p> <p>The general approach is that whatever is overridden/customized using the below approaches, takes the precedence over built-in arguments.</p>"},{"location":"user-guide/compensating-librarys-missing-features/#workflows-jobs-and-steps","title":"Workflows, jobs and steps","text":"<p>They have an extra argument - <code>_customArguments</code> - which is a map from <code>String</code> to whatever values or collections are needed, especially using basic types like booleans, strings or integers, and further nesting of maps and lists.</p> <p>For example:</p> <pre><code>workflow(\n// ...\n_customArguments = mapOf(\n\"dry-run\" to true,\n\"some-string-value\" to \"foobar\",\n\"written-by\" to listOf(\"Alice\", \"Bob\"),\n\"concurrency\" to mapOf(\n\"group\" to expr(\"github.ref\"),\n\"cancel-in-progress\" to \"true\",\n),\n),\n)\n</code></pre>"},{"location":"user-guide/compensating-librarys-missing-features/#actions-inputs","title":"Action's inputs","text":"<p>Each action wrapper has an extra constructor parameter - <code>_customInputs</code> - which is a map from <code>String</code> to <code>String</code>:</p> <pre><code>UploadArtifactV3(\n// ...\n_customInputs = mapOf(\n\"path\" to \"override-path-value\",\n\"answer\" to \"42\",\n),\n)\n</code></pre> <p>You can use it to set inputs that the wrapper doesn't know about, or to set any custom value if the wrapper's typing is incorrect or faulty.</p>"},{"location":"user-guide/compensating-librarys-missing-features/#actions-version","title":"Action's version","text":"<p>Each action wrapper has an extra constructor parameter - <code>_customVersion</code> - which is a string overriding action's version:</p> <pre><code>UploadArtifactV3(\n// ...\n_customVersion = \"v4\",\n)\n</code></pre> <p>It's useful e.g. when the wrapper doesn't keep up with action's versions and the API is fairly compatible, or if you want to use a specific minor version.</p>"},{"location":"user-guide/compensating-librarys-missing-features/#i-still-cannot-customize-what-i-need","title":"I still cannot customize what I need","text":"<p>Well, it means we missed something - sorry for that! Please report it via GitHub issues.</p>"},{"location":"user-guide/getting_started/","title":"Getting started","text":""},{"location":"user-guide/getting_started/#getting-started","title":"Getting started","text":"<p>As an exercise, we'll add a job that prints out <code>Hello world!</code>. Feel free to replace the actual workflow's logic and all names with your own.</p> <ol> <li>Install Kotlin as a stand-alone binary, e.g. from Snap Store when on Linux:    <pre><code>sudo snap install kotlin --classic\n</code></pre>    Make sure this is the newest version available. Kotlin scripting still has some rough edges, and improvements    are introduced with each new Kotlin release.    Also make sure that you use Java 11+.</li> <li>Create a new executable file in your repository:    <pre><code>touch    .github/workflows/hello_world_workflow.main.kts\nchmod +x .github/workflows/hello_world_workflow.main.kts\n</code></pre>    This location is not a hard requirement, it's just recommended for consistency with enforced location of actual    GitHub Actions workflows.</li> <li>Put this content into the previously created file and save it:    <pre><code>#!/usr/bin/env kotlin\n\n@file:DependsOn(\"io.github.typesafegithub:github-workflows-kt:0.48.0\")\n\nimport io.github.typesafegithub.workflows.actions.actions.CheckoutV3\nimport io.github.typesafegithub.workflows.domain.RunnerType.UbuntuLatest\nimport io.github.typesafegithub.workflows.domain.triggers.Push\nimport io.github.typesafegithub.workflows.dsl.workflow\nimport io.github.typesafegithub.workflows.yaml.writeToFile\n\nworkflow(\nname = \"Test workflow\",\non = listOf(Push()),\nsourceFile = __FILE__.toPath(),\n) {\njob(id = \"test_job\", runsOn = UbuntuLatest) {\nuses(name = \"Check out\", action = CheckoutV3())\nrun(name = \"Print greeting\", command = \"echo 'Hello world!'\")\n}\n}.writeToFile()\n</code></pre>    Explanation: first, we create a workflow with the DSL provided by this library. The reason it needs source    file path is to be able to generate consistency checks, to ensure that both source and target files are in sync.    You'll see it in a moment in the generated file. What's written to the <code>workflow</code> variable is an object of type    <code>io.github.typesafegithub.workflows.domain.Workflow</code>, it's not a YAML yet. However, a call to <code>writeToFile()</code>    extension function does the final piece of job.    Alternatively, apart from <code>writeToFile()</code> which puts the string straight into the file under path inferred by the    library or name overridden with <code>targetFileName</code> workflow argument, there's also <code>toYaml()</code> which doesn't touch    any files, it just returns a string with the YAML. It may come in handy when more control over the YAML is needed,    e.g. to do some post-processing.</li> <li>Generate the YAML by calling the above script:    <pre><code>.github/workflows/hello_world_workflow.main.kts\n</code></pre>    It can be also executed straight from IntelliJ, by clicking the green \u25b6\ufe0f button next to the shebang.    Notice that there's an extra job generated by the library that regenerates the YAML in job's runtime and ensures that    it's equal to the YAML committed to the repository.</li> <li>Commit both files, push the changes to GitHub and make sure the workflow is green when ran on GitHub Actions.</li> </ol>"},{"location":"user-guide/job-outputs/","title":"Job outputs","text":""},{"location":"user-guide/job-outputs/#job-outputs","title":"Job outputs","text":"<p>It's possible to pass output from a job in a somewhat type-safe way (that is: types aren't checked, but the field names are).</p> <p>First, define <code>outputs</code> parameter in <code>job</code> function, inheriting from <code>JobOutputs</code>:</p> <pre><code>val myJob = job(\nid = \"my_job\",\nrunsOn = RunnerType.UbuntuLatest,\noutputs = object : JobOutputs() {\nvar myOutput by output()\nvar anotherOutput by output()\n},\n) { ... }\n</code></pre> <p>To set an output from within the job, use <code>jobOutputs</code>, and then an appropriate object field:</p> <pre><code>jobOutputs.myOutput = someStep.outputs.someStepOutput\njobOutputs.anotherOutput = someStep.outputs[\"custom-output\"]\n</code></pre> <p>and then use job's output from another job this way:</p> <pre><code>job(\nid = \"use_output\",\nrunsOn = RunnerType.UbuntuLatest,\nneeds = listOf(myJob),\n) {\nrun(\nname = \"Use outputs\",\ncommand = \"\"\"\n            echo ${expr { myJob.outputs.myOutput }}\n            echo ${expr { myJob.outputs.anotherOutput }}\n        \"\"\".trimIndent(),\n)\n}\n</code></pre>"},{"location":"user-guide/nightly-builds/","title":"Nightly builds","text":""},{"location":"user-guide/nightly-builds/#nightly-builds","title":"Nightly builds","text":"<p>Sometimes you may want to test a change that has been already merged to <code>main</code> or other branch, but not yet officially released. In this case, you can use JitPack to request building the desired version of the library on demand:</p> <p>https://jitpack.io/#typesafegithub/github-workflows-kt</p> <p>To use the newest, bleeding-edge version from <code>main</code> branch, replace your scripts' preamble with:</p> <pre><code>@file:Repository(\"https://jitpack.io\")\n@file:DependsOn(\"com.github.typesafegithub:github-workflows-kt:main-SNAPSHOT\")\n</code></pre> <p>Remember that the version <code>main-SNAPSHOT</code> may return a different build of the library each time because <code>main</code> branch gets new commits over time. If it's important to you to have more stability, consider e.g. pinning your dependency to a specific commit. See the above link on JitPack to learn multiple ways how JitPack can refer to the library's versions.</p> <p>JitPack lazily builds the library on demand, so it may happen that you will wait for the dependency resolution until the build is done. It usually takes up to several minutes, and you can preview the progress on JitPack.</p>"},{"location":"user-guide/type-safe-expressions/","title":"Type-safe expressions","text":""},{"location":"user-guide/type-safe-expressions/#typesafe-github-expressions","title":"Typesafe GitHub Expressions","text":""},{"location":"user-guide/type-safe-expressions/#github-expressions","title":"GitHub expressions","text":"<p>GitHub supports pretty advanced expressions via the <code>${{ ... }}</code> syntax.</p> <p>They include:</p> <ul> <li>functions</li> <li>environment variables</li> <li>secrets</li> <li>different contexts like the <code>runner</code> or the <code>github</code> context</li> <li>events payloads</li> <li>and more (read here).</li> </ul> <p>Here is an example</p> <pre><code>run(\nname = \"Environment variable and functions\",\ncommand = \"echo \\$GITHUB_ACTORS\",\ncondition = \"\\${{invariably()}}\",\n)\nrun(\nname = \"GitHubContext echo sha\",\ncommand = \"echo commit: \\${{ github.sha256 }}  event: \\${{ github.event.release.zip_url }}\",\n)\n</code></pre> <p>Unfortunately, it is easy to get those expressions wrong.</p> <p>In fact this snippet contains four different errors.</p> <p>Can you spot them all?</p> <p>To make life easier, let us introduce type-safe GitHub expressions.</p>"},{"location":"user-guide/type-safe-expressions/#the-expr-helper-function","title":"The <code>expr(\"\")</code> helper function","text":"<p>First, because <code>\\${{ ... }}</code> is awkward in Kotlin, it can be replaced by the <code>expr(\"\")</code> helper function</p> <pre><code>- \"\\${{invariably()}}\"\n+ expr(\"invariably()\")\n</code></pre> <p>But this is still not type-safe.</p>"},{"location":"user-guide/type-safe-expressions/#type-safe-functions-with-the-expr-dsl","title":"Type-safe functions with the <code>expr { }</code>  DSL","text":"<p>We went one step further towards type-safety by introducing the <code>expr { }</code> DSL.</p> <p>Goals:</p> <ul> <li>an invalid expression should not even compile.</li> <li>increase discoverability of what is available.</li> </ul> <p>For example, you can use auto-completion to find out which functions are available:</p> <p></p> <p>Here we immediately see how to fix a first bug in our original snippet:</p> <pre><code>- \"\\${{invariably()}}\"\n- expr(\"invariably()\")\n+ expr { always() }\n</code></pre> <p>Reference: https://docs.github.com/en/actions/learn-github-actions/expressions#functions</p>"},{"location":"user-guide/type-safe-expressions/#the-runner-context","title":"The <code>runner</code> context","text":"<p>The <code>runner</code> context contains information about the runner that is executing the current job.</p> <p>The possible properties are available via <code>expr { runner.xxx }</code> </p> <p>https://docs.github.com/en/actions/learn-github-actions/contexts#example-contents-of-the-runner-context</p>"},{"location":"user-guide/type-safe-expressions/#the-github-context","title":"The <code>github</code> context","text":"<p>The <code>github</code> context contains information about the workflow run and the event that triggered the run.</p> <p>The possible properties are available via <code>expr { github.xxx }</code></p> <p> Here we detect immediatly another bug in our original snippet</p> <pre><code>-command = \"echo commit: ${'$'}{{ github.sha256 }}\n+command = \"echo commit: \" + expr { github.sha }\n</code></pre> <p>Reference: https://docs.github.com/en/actions/learn-github-actions/contexts#github-context</p>"},{"location":"user-guide/type-safe-expressions/#the-githubeventxxx-payload","title":"The <code>github.eventXXX</code> payload","text":"<p>The <code>github.event</code> field is special because it depends on what kind of events triggered the workflow:</p> <ul> <li>Push</li> <li>PullRequest</li> <li>WorkflowDispatch</li> <li>Release</li> <li>...</li> </ul> <p>Since they have a different type, there is a diferent property <code>expr { github.eventXXX }</code>  per type: </p> <p>By leveraging this feature, we quickly fix another bug in our original snippet:</p> <p></p>"},{"location":"user-guide/type-safe-expressions/#default-environment-variables","title":"Default environment variables","text":"<p>GitHub supports a number of default environment variables.</p> <p>They are available directly in the IDE via the library's <code>Contexts.env</code>  By using this feature in our snippet we would have avoided escaping the dollar and the typo:</p> <pre><code>-command = \"echo \\$GITHUB_ACTORS\",\n+command = \"echo \" + Contexts.env.GITHUB_ACTOR,\n</code></pre> <p>Reference: https://docs.github.com/en/actions/learn-github-actions/environment-variables#default-environment-variables</p>"},{"location":"user-guide/type-safe-expressions/#custom-environment-variables","title":"Custom environment variables","text":"<p>You are not limited to the default environment variables.</p> <p>You can create your own type-safe property by using the syntax</p> <p><code>val MY_VARIABLE_NAME by Contexts.env</code></p> <p>For example:</p> <pre><code>val GREETING by Contexts.env\nval FIRST_NAME by Contexts.env\n\njob(\nenv = linkedMapOf(\nGREETING to \"World\",\n),\n) {\nrun(\nname = \"Custom environment variable\",\nenv = linkedMapOf(\nFIRST_NAME to \"Patrick\",\n),\ncommand = \"echo $GREETING $FIRST_NAME\",\n)\n}\n</code></pre> <p>Reference: https://docs.github.com/en/actions/learn-github-actions/environment-variables#about-environment-variables</p>"},{"location":"user-guide/type-safe-expressions/#github-secrets","title":"GitHub Secrets","text":"<p>If you have sensitive information, you should store it as a GitHub secret:</p> <p></p> <p>You use them the same way as environment variables, but using <code>Contexts.secrets</code> instead of <code>Contexts.env</code>:</p> <p><code>val SUPER_SECRET by Contexts.secrets</code></p> <p>For example:</p> <pre><code>val SUPER_SECRET by Contexts.secrets\n\nval SECRET by Contexts.env\nval TOKEN by Contexts.env\n\njob(id = \"job1\", runsOn = RunnerType.UbuntuLatest) {\nrun(\nname = \"Encrypted secret\",\nenv = linkedMapOf(\nSECRET to expr { SUPER_SECRET },\nTOKEN to expr { secrets.GITHUB_TOKEN },\n),\ncommand = \"echo secret=$SECRET token=$TOKEN\",\n)\n}\n</code></pre>"},{"location":"user-guide/type-safe-expressions/#missing-a-feature","title":"Missing a feature?","text":"<p>GitHub has more contexts that we don't support yet: https://docs.github.com/en/actions/learn-github-actions/contexts</p> <p>There are more <code>github.event</code> payloads that we currently do not support: https://docs.github.com/en/developers/webhooks-and-events/webhooks/webhook-events-and-payloads</p> <p>We feel what we have is a pretty good start, but if you need an additional feature, you can create an issue</p> <p>Or maybe have a look how this type-safe feature is implemented in io.github.typesafegithub.workflows.dsl.expressions and submit a pull request \ud83d\ude4f\ud83c\udffb</p>"},{"location":"user-guide/using-actions/","title":"Using actions","text":""},{"location":"user-guide/using-actions/#using-actions","title":"Using actions","text":"<p>As a reminder, to be able to use an action, you have to know its owner, name and version, e.g. <code>actions/checkout@v3</code>. The library comes bundled with some popular actions, but you can consume any action you want. Read on to learn about your possibilities.</p>"},{"location":"user-guide/using-actions/#built-in-actions","title":"Built-in actions","text":"<p>Take a look here: Supported actions. These are actions ready to use, grouped by owners. For <code>actions/checkout@v3</code>, there's <code>CheckoutV3</code> accepting all inputs defined in its metadata file, along with some basic typing. You may notice that for each major version, a separate class exists. It's because it's assumed Semantic Versioning is used to version the actions, as recommended by GitHub. Each new major version means a breaking change, and it usually means that the Kotlin wrapper for the action needs a breaking change as well.</p>"},{"location":"user-guide/using-actions/#requirements-for-adding-a-new-action","title":"Requirements for adding a new action","text":"<p>An action is eligible to be added to this library (i.e. have its Kotlin wrapper generated and maintained by the library) if the following conditions are fulfilled:</p> <ul> <li>follows Semantic Versioning, with exceptions for pre-releases (like <code>v0.2</code>)</li> <li>provides major version tags, as described here.   An example valid tag is <code>v2</code> that points to the newest release with major version number 2. Example invalid tags are   <code>v2.1.0</code>, <code>latest</code> or <code>main</code></li> </ul> <p>Nice to have:</p> <ul> <li>provides typings using github-actions-typing</li> </ul>"},{"location":"user-guide/using-actions/#user-defined-actions","title":"User-defined actions","text":"<p>If your action is not bundled with the library, you are in a hurry and contributing to the library now is not an option, you have two ways to proceed.</p>"},{"location":"user-guide/using-actions/#typed-wrapper","title":"Typed wrapper","text":"<p>When to use this approach</p> <p>It lets you create an action wrapper in a similar manner that is provided by the built-in action wrappers in this library, i.e. a class that takes some constructor arguments with types of your choice, and maps them to strings inside <code>toYamlArguments</code>. Use it to have better type-safety when using the wrapper.</p>"},{"location":"user-guide/using-actions/#repository-based-actions","title":"Repository based actions","text":"<p>In case of a repository based action which most GitHub actions are, inherit from <code>RegularAction</code> and in case of actions without explicit outputs, use the <code>Actions.Outputs</code> class as type argument:</p> <pre><code>class MyCoolActionV3(\nprivate val someArgument: String,\n) : RegularAction&lt;Action.Outputs&gt;(\"acmecorp\", \"cool-action\", \"v3\") {\noverride fun toYamlArguments() = linkedMapOf(\n\"some-argument\" to someArgument,\n)\n\noverride fun buildOutputObject(stepId: String) = Outputs(stepId)\n}\n</code></pre> <p>or, in case of actions with explicit outputs, create a subclass of <code>Action.Outputs</code> for the type argument:</p> <pre><code>class MyCoolActionV3(\nprivate val someArgument: String,\n) : RegularAction&lt;MyCoolActionV3.Outputs&gt;(\"acmecorp\", \"cool-action\", \"v3\") {\noverride fun toYamlArguments() = linkedMapOf(\n\"some-argument\" to someArgument,\n)\n\noverride fun buildOutputObject(stepId: String) = Outputs(stepId)\n\nclass Outputs(stepId: String) : Action.Outputs(stepId) {\npublic val coolOutput: String = \"steps.$stepId.outputs.coolOutput\"\n}\n}\n</code></pre> <p>Once you've got your action, it's now as simple as using it like this:</p> <pre><code>uses(\nname = \"FooBar\",\naction = MyCoolActionV3(someArgument = \"foobar\"),\n)\n</code></pre>"},{"location":"user-guide/using-actions/#local-actions","title":"Local actions","text":"<p>In case of a local action you have available in your repository or cloned from a private repository, inherit from <code>LocalAction</code> instead:</p> <pre><code>class MyCoolLocalActionV3(\nprivate val someArgument: String,\n) : LocalAction&lt;Action.Outputs&gt;(\"./.github/actions/cool-action\") {\noverride fun toYamlArguments() = linkedMapOf(\n\"some-argument\" to someArgument,\n)\n\noverride fun buildOutputObject(stepId: String) = Outputs(stepId)\n}\n</code></pre>"},{"location":"user-guide/using-actions/#published-docker-actions","title":"Published Docker actions","text":"<p>In case of a published Docker action, inherit from <code>DockerAction</code> instead:</p> <pre><code>class MyCoolDockerActionV3(\nprivate val someArgument: String,\n) : DockerAction&lt;Action.Outputs&gt;(\"alpine\", \"latest\") {\noverride fun toYamlArguments() = linkedMapOf(\n\"some-argument\" to someArgument,\n)\n\noverride fun buildOutputObject(stepId: String) = Outputs(stepId)\n}\n</code></pre>"},{"location":"user-guide/using-actions/#untyped-wrapper","title":"Untyped wrapper","text":"<p>When to use this approach</p> <p>It omits typing entirely, and both inputs and outputs are referenced using strings. Use it if you don't care about types because you're in the middle of experimenting. It's also more convenient to produce such code by a code generator.</p>"},{"location":"user-guide/using-actions/#repository-based-actions_1","title":"Repository based actions","text":"<p>In case of a repository based action which most GitHub actions are, use a <code>CustomAction</code>:</p> <pre><code>val customAction = CustomAction(\nactionOwner = \"xu-cheng\",\nactionName = \"latex-action\",\nactionVersion = \"v2\",\ninputs = linkedMapOf(\n\"root_file\" to \"report.tex\",\n\"compiler\" to \"latexmk\",\n),\n)\n</code></pre> <p>If your custom action has outputs, you can access them, albeit in a type-unsafe manner:</p> <pre><code>job(id = \"test_job\", runsOn = RunnerType.UbuntuLatest) {\nval customActionStep = uses(\nname = \"Some step with output\",\naction = customAction,\n)\n\n// use your outputs:\nprintln(expr(customActionStep.outputs[\"custom-output\"]))\n}\n</code></pre>"},{"location":"user-guide/using-actions/#local-actions_1","title":"Local actions","text":"<p>In case of a local action you have available in your repository or cloned from a private repository, use a <code>CustomLocalAction</code> instead:</p> <pre><code>val customAction = CustomLocalAction(\nactionPath = \"./.github/actions/setup-build-env\",\n)\n</code></pre>"},{"location":"user-guide/using-actions/#published-docker-actions_1","title":"Published Docker actions","text":"<p>In case of a published Docker action, use a <code>CustomDockerAction</code> instead:</p> <pre><code>val customAction = CustomDockerAction(\nactionImage = \"alpine\",\nactionTag = \"latest\",\n)\n</code></pre>"}]}